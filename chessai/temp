#include <torch/torch.h>
#include <vector>
#include <string>
#include <iostream>
#include <random>

#include <game.h>
#include <chessgame.h>

using namespace torch;
using namespace std;

#define GLOBAL 17
#define PIECE_CENTRIC 4
#define SQUARE_CENTRIC 4
#define TOTAL 25

// I think I should not use convolution layers because the input space consists
// of "sharp edges" like when the data switches from representing information
// about a queen to that about a knight

// Linear layers seem to be a decent starting point

// It seems that parameterise the game everytime is a waste of time because the
// majority of the parameters won't change but I don't know what a good way to
// detect the unchanged parameters without redoing all the work is

vector <Tensor> parameterise(Game *game);
vector <double> parseGlobal(Game *game);
vector <double> parsePiece(Game *game);
vector <double> parseSquare(Game *game);
double heuristic(Game *game);

struct EvaluatorImpl : nn::Module {
    EvaluatorImpl():
        global(nn::LinearOptions(GLOBAL, GLOBAL)), 
        piece_centric(nn::LinearOptions(PIECE_CENTRIC, PIECE_CENTRIC)), 
        square_centric(nn::LinearOptions(SQUARE_CENTRIC, SQUARE_CENTRIC)), 
        second(nn::LinearOptions(TOTAL, 10)), 
        third(nn::LinearOptions(10, 1)) {
            register_module("global", global);
            register_module("piece_centric", piece_centric);
            register_module("square_centric", square_centric);
            register_module("second", second);
            register_module("third", third);
    }
    Tensor forward(Tensor global_tensor, Tensor piece_tensor, Tensor square_tensor) {
        global_tensor = relu(global(global_tensor));
        piece_tensor = relu(piece_centric(piece_tensor));
        square_tensor = relu(square_centric(square_tensor));
        Tensor total = torch::cat({global_tensor, piece_tensor, square_tensor}, 0);
        total = relu(second(total));
        total = tanh(third(total));
        return total;
    }
    nn::Linear global, piece_centric, square_centric, second, third;
};
TORCH_MODULE(Evaluator);

#define POINT cout << count << endl; count++;

struct ChessBot {
    Game *game;
    Evaluator evaluator;
    bool white;

    ChessBot(Game *game, Evaluator evaluator, bool white) {
        this->game = game;
        this->evaluator = evaluator;
        this->white = white;
    }
    void makeMove() {
        game->updateMoves();
        vector <GameMove> moves = game->getMoves();
        double best = -1;
        GameMove *select = NULL;
        int tiedBest = 0;
        for (auto it = moves.begin(); it != moves.end(); it++) {
            game->tryMove(*it);
            vector <Tensor> data = parameterise(game);

            evaluator->zero_grad();
            Tensor t_eval = evaluator->forward(data[0], data[1], data[2]);
            double eval = t_eval.item().toDouble();
            double target = heuristic(game);
            // cout << eval << "," << target << endl;
            Tensor t_target = torch::full({1}, eval);
            Tensor d_loss = l1_loss(t_eval, t_target);
            d_loss.backward();

            if (!white) {
                eval = -eval;
            }
            if (eval > best) {
                select = &*it;
                best = eval;
                tiedBest = 1;
            }
            if (eval == best) {
                tiedBest++;
                if ((float) rand() / (float) RAND_MAX < 1 / tiedBest) {
                    select = &*it;
                    best = eval;
                }
            }
            game->reverseLast();
        }
        // cout << select << "\n";
        game->tryMove(*select);
    }
};

int main() {
    Evaluator evaluator = Evaluator();
    optim::Adam evaluator_optimiser(evaluator->parameters(), optim::AdamOptions().lr(0.1));

    load(evaluator, "evaluator.pt");
    load(evaluator_optimiser, "evaluator_optimiser.pt");

    for (int i = 0; i < 1; i++) {
        cout << i << endl;
        Game *game = new ChessGame();
        game->setUp();

        ChessBot whiteBot = ChessBot(game, evaluator, true);
        ChessBot blackBot = ChessBot(game, evaluator, false);    
    
        // cout << game->getBoard()->snapshot() << endl;
        bool result = false;
        while (!game->isFinished()) {
            whiteBot.makeMove();
            result = game->checkResult();

            evaluator_optimiser.step();

            cout << game->getBoard()->snapshot() << endl;
            if (game->isFinished()) {
                break;
            }
            blackBot.makeMove();
            result = game->checkResult();

            evaluator_optimiser.step();

            cout << game->getBoard()->snapshot() << endl;
        }
        if (result) {
            cout << "win\n";
        } else {
            cout << "draw\n";
        }

        // Print values
        // for (const auto& p : evaluator->named_parameters()) {
        //     cout << p.key() << ": " << p.value() << endl;
        // }
    }

    save(evaluator, "evaluator.pt");
    save(evaluator_optimiser, "evaluator_optimiser.pt");

    return 0;
}

vector <Tensor> parameterise(Game *game) {
    vector <Tensor> tensors;
    
    vector <double> v_global = parseGlobal(game);
    
    Tensor global = torch::from_blob(v_global.data(), {GLOBAL}, TensorOptions().dtype(kFloat32)).to(kFloat32);

    tensors.push_back(global);
    tensors.push_back(torch::rand(PIECE_CENTRIC));
    tensors.push_back(torch::rand(SQUARE_CENTRIC));
    // TODO
    return tensors;
}

vector <double> parseGlobal(Game *game) {
    vector <double> v_global;
    bool white_turn = game->getCurrentPlayer()->getColour() == WHITE;
    Player *white = white_turn ? game->getCurrentPlayer() : game->getOppositePlayer();
    Player *black = white_turn ? game->getOppositePlayer() : game->getCurrentPlayer();
    // side to move
    if (white_turn) {
        v_global.push_back(1);
    } else {
        v_global.push_back(-1);
    }
    // castle rights
    v_global.push_back(game->getTrackers()[WLC]);
    v_global.push_back(game->getTrackers()[WSC]);
    v_global.push_back(game->getTrackers()[BLC]);
    v_global.push_back(game->getTrackers()[BSC]);
    // material configuration
    enum PieceType {WK, WQ, WR, WB, WN, WP, BK, BQ, BR, BB, BN, BP, NUM_PieceType};
    vector <double> pieceCount(NUM_PieceType, 0);

    vector <Piece *> whitePieces = white->getPieces();
    for (auto it = whitePieces.begin(); it != whitePieces.end(); it++) {
        string name = (*it)->getName();
        if (name == "king") {
            pieceCount[WK]++;
        } else if (name == "queen") {
            pieceCount[WQ]++;
        } else if (name == "rook") {
            pieceCount[WR]++;
        } else if (name == "bishop") {
            pieceCount[WB]++;
        } else if (name == "knight") {
            pieceCount[WN]++;
        } else if (name == "pawn") {
            pieceCount[WP]++;
        }
    }

    vector <Piece *> blackPieces = black->getPieces();
    for (auto it = blackPieces.begin(); it != blackPieces.end(); it++) {
        string name = (*it)->getName();
        if (name == "king") {
            pieceCount[BK]++;
        } else if (name == "queen") {
            pieceCount[BQ]++;
        } else if (name == "rook") {
            pieceCount[BR]++;
        } else if (name == "bishop") {
            pieceCount[BB]++;
        } else if (name == "knight") {
            pieceCount[BN]++;
        } else if (name == "paBn") {
            pieceCount[BP]++;
        }
    }

    v_global.insert(v_global.end(), pieceCount.begin(), pieceCount.end());

    return v_global;
}

double heuristic(Game *game) {
    bool white_turn = game->getCurrentPlayer()->getColour() == WHITE;
    Player *white = white_turn ? game->getCurrentPlayer() : game->getOppositePlayer();
    Player *black = white_turn ? game->getOppositePlayer() : game->getCurrentPlayer();
    bool result = game->checkResult();
    game->updateMoves();
    if (game->isFinished()) {
        if (result) {
            game->setFinished(false);
            return white_turn ? -1 : 1;
        }
        game->setFinished(false);
        return 0;
    }

    double white_pv = 0;
    double black_pv = 0;
    vector <Piece *> whitePieces = white->getPieces();
    for (auto it = whitePieces.begin(); it != whitePieces.end(); it++) {
        if ((*it)->getSquare() != NULL) {
            string name = (*it)->getName();
            if (name == "queen") {
                white_pv += 9;
            } else if (name == "rook") {
                white_pv += 5;
            } else if (name == "bishop") {
                white_pv += 3.1;
            } else if (name == "knight") {
                white_pv += 2.9;
            } else if (name == "pawn") {
                white_pv += 1;
            }
        }
    }

    vector <Piece *> blackPieces = black->getPieces();
    for (auto it = blackPieces.begin(); it != blackPieces.end(); it++) {
        if ((*it)->getSquare() != NULL) {
            string name = (*it)->getName();
            if (name == "queen") {
                black_pv += 9;
            } else if (name == "rook") {
                black_pv += 5;
            } else if (name == "bishop") {
                black_pv += 3.1;
            } else if (name == "knight") {
                black_pv += 2.9;
            } else if (name == "pawn") {
                black_pv += 1;
            }
        }
    }

    double moveBonus = game->getMoves().size() * 0.05;
    if (white_turn) {
        white_pv += moveBonus;
    } else {
        black_pv += moveBonus;
    }
    return tanh(white_pv - black_pv);
}